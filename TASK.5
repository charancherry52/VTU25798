{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\tab\tab\tab Ant Colony Optimization\tab\tab\par
\par
Program:\par
import numpy as np\par
from numpy import inf\par
#given values for the problems\par
d = np.array([[0,10,12,11,14]\par
 ,[10,0,13,15,8]\par
 ,[12,13,0,9,14]\par
 ,[11,15,9,0,16]\par
 ,[14,8,14,16,0]])\par
iteration = 100\par
n_ants = 5\par
n_citys = 5\par
# intialization part\par
m = n_ants\par
n = n_citys\par
e = .5 #evaporation rate\par
alpha = 1 #pheromone factor\par
beta = 2 #visibility factor\par
#calculating the visibility of the next city visibility(i,j)=1/d(i,j)\par
visibility = 1/d\par
visibility[visibility == inf ] = 0\par
#intializing pheromne present at the paths to the cities\par
pheromne = .1*np.ones((m,n))\par
#intializing the rute of the ants with size rute(n_ants,n_citys+1)\par
#note adding 1 because we want to come back to the source city\par
rute = np.ones((m,n+1))\par
for ite in range(iteration):\par
\par
 rute[:,0] = 1 #initial starting and ending positon of every ants '1' i.e city '1'\par
\par
 for i in range(m):\par
\par
 temp_visibility = np.array(visibility) #creating a copy of visibility\par
\par
 for j in range(n-1):\par
 #print(rute)\par
\par
 combine_feature = np.zeros(5) #intializing combine_feature array to zero\par
 cum_prob = np.zeros(5) #intializing cummulative probability array to zeros\par
\par
 cur_loc = int(rute[i,j]-1) #current city of the ant\par
\par
 temp_visibility[:,cur_loc] = 0 #making visibility of the current city as zero\par
\par
 p_feature = np.power(pheromne[cur_loc,:],beta) #calculating pheromne feature\par
 v_feature = np.power(temp_visibility[cur_loc,:],alpha) #calculating visibility feature\par
\par
 p_feature = p_feature[:,np.newaxis] #adding axis to make a size[5,1]\par
 v_feature = v_feature[:,np.newaxis] #adding axis to make a size[5,1]\par
\par
 combine_feature = np.multiply(p_feature,v_feature) #calculating the combine feature\par
\par
 total = np.sum(combine_feature) #sum of all the feature\par
\par
 probs = combine_feature/total #finding probability of element probs(i) =\par
comine_feature(i)/total\par
\par
 cum_prob = np.cumsum(probs) #calculating cummulative sum\par
 #print(cum_prob)\par
 r = np.random.random_sample() #randon no in [0,1)\par
 #print(r)\par
 city = np.nonzero(cum_prob>r)[0][0]+1 #finding the next city having probability\par
higher then random(r)\par
 #print(city)\par
\par
 rute[i,j+1] = city #adding city to route\par
\par
 left = list(set([i for i in range(1,n+1)])-set(rute[i,:-2]))[0] #finding the last untraversed\par
city to route\par
\par
 rute[i,-2] = left #adding untraversed city to route\par
\par
 rute_opt = np.array(rute) #intializing optimal route\par
\par
 dist_cost = np.zeros((m,1)) #intializing total_distance_of_tour with zero\par
\par
 for i in range(m):\par
\par
 s = 0\par
 for j in range(n-1):\par
\par
 s = s + d[int(rute_opt[i,j])-1,int(rute_opt[i,j+1])-1] #calcualting total tour distance\par
\par
 dist_cost[i]=s #storing distance of tour for 'i'th ant at location 'i'\par
\par
 dist_min_loc = np.argmin(dist_cost) #finding location of minimum of dist_cost\par
 dist_min_cost = dist_cost[dist_min_loc] #finging min of dist_cost\par
\par
 best_route = rute[dist_min_loc,:] #intializing current traversed as best route\par
 pheromne = (1-e)*pheromne #evaporation of pheromne with (1-e)\par
\par
 for i in range(m):\par
 for j in range(n-1):\par
 dt = 1/dist_cost[i]\par
 pheromne[int(rute_opt[i,j])-1,int(rute_opt[i,j+1])-1] = pheromne[int(rute_opt[i,j])-\par
1,int(rute_opt[i,j+1])-1] + dt\par
 #updating the pheromne with delta_distance\par
 #delta_distance will be more with min_dist i.e adding more weight to that route\par
peromne\par
print('route of all the ants at the end :')\par
print(rute_opt)\par
print()\par
print('best path :',best_route)\par
print('cost of the best path',int(dist_min_cost[0]) + d[int(best_route[-2])-1,0])\par
Output:\par
Route of all ants at the end:\par
[[1.4.3.5.2.1]\par
 [1.4.3.5.2.1]\par
 [1.4.3.5.2.1]\par
 [1.4.3.5.2.1]\par
 [1.4.3.5.2.1]]\par
Best path: [1.4.3.5.2.1]\par
Cost of the best path=52.\par
}
