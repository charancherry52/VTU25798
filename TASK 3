{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9                                                            A * Algorithm\par
\par
Program :\par
def aStarAlgo(start_node, stop_node):\par
 open_set = set([start_node])\par
 closed_set = set()\par
 g = \{\} # store distance from starting node\par
 parents = \{\} # parents contain an adjacency map of all nodes\par
 # distance of starting node from itself is zero\par
 g[start_node] = 0\par
 # start_node is the root node, so it has no parent nodes\par
 # so start_node is set to its own parent node\par
 parents[start_node] = start_node\par
 while len(open_set) > 0:\par
 n = None\par
 # node with the lowest f() is found\par
 for v in open_set:\par
 if n is None or g[v] + heuristic(v) < g[n] + heuristic(n):\par
 n = v\par
 if n == stop_node or n is None or Graph_nodes[n] is None:\par
 break\par
 else:\par
 for m, weight in get_neighbors(n):\par
 # nodes 'm' not in open_set and closed_set are added to open_set\par
 # n is set as its parent\par
 if m not in open_set and m not in closed_set:\par
 open_set.add(m)\par
 parents[m] = n\par
 g[m] = g[n] + weight\par
 # for each node m, compare its distance from start i.e g(m)\par
 # to the from start through n node\par
 else:\par
 if g[m] > g[n] + weight:\par
 # update g(m)\par
 g[m] = g[n] + weight\par
 # change parent of m to n\par
 parents[m] = n\par
 # if m is in closed_set, remove and add to open_set\par
 if m in closed_set:\par
 closed_set.remove(m)\par
 open_set.add(m)\par
 # remove n from the open_set and add it to closed_set\par
 # because all of its neighbors were inspected\par
 open_set.remove(n)\par
 closed_set.add(n)\par
 if n is None:\par
 print('Path does not exist!')\par
 return None\par
 # if the current node is the stop_node,\par
 # then we begin reconstructing the path from it to the start_node\par
 if n == stop_node:\par
 path = []\par
 while parents[n] != n:\par
 path.append(n)\par
 n = parents[n]\par
 path.append(start_node)\par
 path.reverse()\par
 print('Path found:', path)\par
 return path\par
 print('Path does not exist!')\par
 return None\par
# define function to return neighbors and their distances from the passed node\par
def get_neighbors(v):\par
 if v in Graph_nodes:\par
 return Graph_nodes[v]\par
 else:\par
 return None\par
# for simplicity, we'll consider heuristic distances given\par
# and this function returns heuristic distance for all nodes\par
def heuristic(n):\par
 h_dist = \{\par
 'A': 11,\par
 'B': 6,\par
 'C': 5,\par
 'D': 7,\par
 'E': 3,\par
 'F': 6,\par
 'G': 5,\par
 'H': 3,\par
 'I': 1,\par
 'J': 0\par
 \}\par
 return h_dist[n]\par
# Describe your graph here\par
Graph_nodes = \{\par
 'A': [('B', 6), ('F', 3)],\par
 'B': [('A', 6), ('C', 3), ('D', 2)],\par
 'C': [('B', 3), ('D', 1), ('E', 5)],\par
 'D': [('B', 2), ('C', 1), ('E', 8)],\par
 'E': [('C', 5), ('D', 8), ('I', 5), ('J', 5)],\par
 'F': [('A', 3), ('G', 1), ('H', 7)],\par
 'G': [('F', 1), ('I', 3)],\par
 'H': [('F', 7), ('I', 2)],\par
 'I': [('E', 5), ('G', 3), ('H', 2), ('J', 3)],\par
\}\par
print("Following is the A* Algorithm:")\par
aStarAlgo('A','j')\par
\par
ouput:\par
